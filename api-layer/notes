Any RPC should check for Main Instance lost, return INSTANCE_LOST and Overlay convert to INITIALIZATION_FAILED

CreateSession is an RPC Call
    parameters are:
        const XrInstanceCreateInfo*                 instanceCreateInfo;
        const XrSessionCreateInfo*                  createInfo;
        XrSession*                                  session;
    sendRPC["instanceCreateInfo"] = "%(member)s = gOverlaysLayerXrInstanceToHandleInfo.at(*instance).createInfo;\n"
    sendRPC["instanceCreateInfo"] = "%(member)s = gOverlaysLayerXrInstanceToHandleInfo.at(*instance).createInfo;\n"
    if not annotated, parameters are from and then to command call
    otherwise parameters annoted with "sendRPC" and "receiveRPC" for code to insert before RPC and after

struct OverlaysLayerRPCCreateSession
{
    XrFormFactor                                formFactor;
    const XrInstanceCreateInfo*                 instanceCreateInfo;
    const XrSessionCreateInfo*                  createInfo;
    XrSession*                                  session;
};


// Serialization helpers ----------------------------------------------------

// MUST BE DEFAULT ONLY FOR LEAF OBJECTS (no pointers in them)
template <typename T>
T* IPCSerialize(IPCBuffer& ipcbuf, IPCXrHeader* header, const T* p)
{
    if(!p)
        return nullptr;

    T* t = new(ipcbuf) T;
    if(!t)
        return nullptr;

    *t = *p;
    return t;
}

// MUST BE DEFAULT ONLY FOR LEAF OBJECTS (no pointers in them)
template <typename T>
T* IPCSerialize(IPCBuffer& ipcbuf, IPCXrHeader* header, const T* p, size_t count)
{
    if(!p)
        return nullptr;

    T* t = new(ipcbuf) T[count];
    if(!t)
        return nullptr;

    for(size_t i = 0; i < count; i++)
        t[i] = p[i];

    return t;
}

// MUST BE DEFAULT ONLY FOR LEAF OBJECTS (no pointers in them)
template <typename T>
T* IPCSerializeNoCopy(IPCBuffer& ipcbuf, IPCXrHeader* header, const T* p)
{
    if(!p)
        return nullptr;

    T* t = new(ipcbuf) T;
    if(!t)
        return nullptr;

    return t;
}

// MUST BE DEFAULT ONLY FOR LEAF OBJECTS (no pointers in them)
template <typename T>
T* IPCSerializeNoCopy(IPCBuffer& ipcbuf, IPCXrHeader* header, const T* p, size_t count)
{
    if(!p)
        return nullptr;

    T* t = new(ipcbuf) T[count];
    if(!t)
        return nullptr;

    return t;
}

// MUST BE DEFAULT ONLY FOR LEAF OBJECTS (no pointers in them)
template <typename T>
void IPCCopyOut(T* dst, const T* src)
{
    if(!src)
        return;

    *dst = *src;
}

// MUST BE DEFAULT ONLY FOR LEAF OBJECTS (no pointers in them)
template <typename T>
void IPCCopyOut(T* dst, const T* src, size_t count)
{
    if(!src)
        return;

    for(size_t i = 0; i < count; i++) {
        dst[i] = src[i];
    }
}

// Serialization of XR structs ----------------------------------------------

XrBaseInStructure* IPCSerialize(IPCBuffer& ipcbuf, IPCXrHeader* header, const XrBaseInStructure* srcbase, CopyType copyType)
{
    return CopyXrStructChain(srcbase, copyType,
            [&ipcbuf](size_t size){return ipcbuf.allocate(size);},
            [&ipcbuf,&header](void* pointerToPointer){header->addOffsetToPointer(ipcbuf.base, pointerToPointer);});
}

// CopyOut XR structs -------------------------------------------------------

template <>
void IPCCopyOut(XrBaseOutStructure* dstbase, const XrBaseOutStructure* srcbase)
{
    bool skipped = true;

    do {
        skipped = false;

        if(!srcbase) {
            return;
        }

        switch(dstbase->type) {
            // XXX Generate these
#if 0
            case XR_TYPE_SPACE_LOCATION: {
                auto src = reinterpret_cast<const XrSpaceLocation*>(srcbase);
                auto dst = reinterpret_cast<XrSpaceLocation*>(dstbase);
                dst->locationFlags = src->locationFlags;
                dst->pose = src->pose;
                break;
            }

            case XR_TYPE_GRAPHICS_REQUIREMENTS_D3D11_KHR: {
                auto src = reinterpret_cast<const XrGraphicsRequirementsD3D11KHR*>(srcbase);
                auto dst = reinterpret_cast<XrGraphicsRequirementsD3D11KHR*>(dstbase);
                dst->adapterLuid = src->adapterLuid;
                dst->minFeatureLevel = src->minFeatureLevel;
                break;
            }

            case XR_TYPE_FRAME_STATE: {
                auto src = reinterpret_cast<const XrFrameState*>(srcbase);
                auto dst = reinterpret_cast<XrFrameState*>(dstbase);
                dst->predictedDisplayTime = src->predictedDisplayTime;
                dst->predictedDisplayPeriod = src->predictedDisplayPeriod;
                dst->shouldRender = src->shouldRender;
                break;
            }

            case XR_TYPE_INSTANCE_PROPERTIES: {
                auto src = reinterpret_cast<const XrInstanceProperties*>(srcbase);
                auto dst = reinterpret_cast<XrInstanceProperties*>(dstbase);
                dst->runtimeVersion = src->runtimeVersion;
                strncpy_s(dst->runtimeName, src->runtimeName, XR_MAX_RUNTIME_NAME_SIZE);
                break;
            }

            case XR_TYPE_EXTENSION_PROPERTIES: {
                auto src = reinterpret_cast<const XrExtensionProperties*>(srcbase);
                auto dst = reinterpret_cast<XrExtensionProperties*>(dstbase);
                strncpy_s(dst->extensionName, src->extensionName, XR_MAX_EXTENSION_NAME_SIZE);
                dst->extensionVersion = src->extensionVersion;
                break;
            }

            case XR_TYPE_SYSTEM_PROPERTIES: {
                auto src = reinterpret_cast<const XrSystemProperties*>(srcbase);
                auto dst = reinterpret_cast<XrSystemProperties*>(dstbase);
                dst->systemId = src->systemId;
                dst->vendorId = src->vendorId;
                dst->graphicsProperties = src->graphicsProperties;
                dst->trackingProperties = src->trackingProperties;
                strncpy_s(dst->systemName, src->systemName, XR_MAX_SYSTEM_NAME_SIZE);
                break;
            }

            case XR_TYPE_VIEW_CONFIGURATION_PROPERTIES: {
                auto src = reinterpret_cast<const XrViewConfigurationProperties*>(srcbase);
                auto dst = reinterpret_cast<XrViewConfigurationProperties*>(dstbase);
                dst->viewConfigurationType = src->viewConfigurationType;
                dst->fovMutable = src->fovMutable;
                break;
            }

            case XR_TYPE_VIEW_CONFIGURATION_VIEW: {
                auto src = reinterpret_cast<const XrViewConfigurationView*>(srcbase);
                auto dst = reinterpret_cast<XrViewConfigurationView*>(dstbase);
                dst->recommendedImageRectWidth = src->recommendedImageRectWidth;
                dst->maxImageRectWidth = src->maxImageRectWidth;
                dst->recommendedImageRectHeight = src->recommendedImageRectHeight;
                dst->maxImageRectHeight = src->maxImageRectHeight;
                dst->recommendedSwapchainSampleCount = src->recommendedSwapchainSampleCount;
                dst->maxSwapchainSampleCount = src->maxSwapchainSampleCount;
                break;
            }
#endif

            default: {
                // I don't know what this is, drop it and keep going
                OverlaysLayerLogMessage(XR_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT, "unknown",
                    OverlaysLayerNoObjectInfo, fmt("WARNING: IPCCopyOut called to copy out to %p of unknown type %d - skipped.\n", dstbase, dstbase->type).c_str());

                dstbase = dstbase->next;
                skipped = true;

                // Don't increment srcbase.  Unknown structs were
                // dropped during serialization, so keep going until we
                // see a type we know and then we'll have caught up with
                // what was serialized.
                //
                break;
            }
        }
    } while(skipped);

    IPCCopyOut(dstbase->next, srcbase->next);
}

template <>
OverlaysLayerRPCCreateSession* IPCSerialize(IPCBuffer& ipcbuf, IPCHeader* header, const OverlaysLayerRPCCreateSession* src)
{
    auto dst = new(ipcbuf) OverlaysLayerRPCCreateSession;

    dst->formFactor = src->formFactor;

    dst->instanceCreateInfo = reinterpret_cast<const XrInstanceCreateInfo*>(IPCSerialize(ipcbuf, header, reinterpret_cast<const XrBaseInStructure*>(src->instanceCreateInfo), COPY_EVERYTHING));
    header->addOffsetToPointer(ipcbuf.base, &dst->instanceCreateInfo);
    dst->createInfo = reinterpret_cast<const XrSessionCreateInfo*>(IPCSerialize(ipcbuf, header, reinterpret_cast<const XrBaseInStructure*>(src->createInfo), COPY_EVERYTHING));
    header->addOffsetToPointer(ipcbuf.base, &dst->createInfo);

    dst->session = IPCSerializeNoCopy(ipcbuf, header, src->session);
    header->addOffsetToPointer(ipcbuf.base, &dst->session);

    return dst;
}

template <>
void IPCCopyOut(OverlaysLayerRPCCreateSession* dst, const OverlaysLayerRPCCreateSession* src)
{
    IPCCopyOut(dst->session, src->session);
}

// Can this be generated?
XrResult OverlaysLayerCreateSessionOverlay(
    XrInstance                                  instance,
    const XrSessionCreateInfo*                  createInfo,
    XrSession*                                  session)
{
    XrResult result = XR_SUCCESS;

    // Only on Overlay XrSession Creation, connect to the main app.
    make sure we don't already have an overlay session - design doc stated one per app
    if(!ConnectToMain(instance)) {
        OverlaysLayerLogMessage(gNegotiationChannels.instance, XR_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT, "XrCreateSession",
            OverlaysLayerNoObjectInfo, "WARNING: couldn't connect to main app.\n");
        return XR_ERROR_INITIALIZATION_FAILED;
    }

    // Get our tracked information on this XrInstance 
    std::unique_lock<std::mutex> mlock(gOverlaysLayerXrInstanceToHandleInfoMutex);
    OverlaysLayerXrInstanceHandleInfo& instanceInfo = gOverlaysLayerXrInstanceToHandleInfo.at(instance);

    // Create a header for RPC to MainAsOverlay
    IPCBuffer ipcbuf = gConnectionToMain.conn.GetIPCBuffer();
    IPCHeader* header = new(ipcbuf) IPCHeader{IPC_XR_CREATE_SESSION};

    // Serialize our RPC args into the IPC buffer in shared memory
    XrFormFactor formFactor;
    {
        // XXX REALLY SHOULD RPC TO GET THE REMOTE SYSTEMID HERE AND THEN SUBSTITUTE THAT
        std::unique_lock<std::mutex> m(gOverlaysLayerSystemIdToAtomInfoMutex);
        XrSystemGetInfo* systemGetInfo = gOverlaysLayerSystemIdToAtomInfo.at(createInfo.systemId).getInfo;
        formFactor = systemGetInfo.formFactor;
        // XXX should check here that systemGetInfo->next == nullptr
        // but current API Layer is not specified to support any
        // XrSystemId-related extensions
    }

    OverlaysLayerRPCCreateSession args { formFactor, instanceInfo.createInfo, createInfo, session }; // ignore instance since Main won't use ours
    OverlaysLayerRPCCreateSession* argsSerialized = IPCSerialize(ipcbuf, header, &args);

    // Make pointers relative in anticipation of RPC (who will make them absolute, work on them, then make them relative again)
    header->makePointersRelative(ipcbuf.base);

    // Release Main process to do our work
    gConnectionToMain.conn.FinishOverlayRequest();

    // Wait for Main to report to us it has done the work
    bool success = gConnectionToMain->conn.WaitForMainResponse();
    if(!success) {
        OverlaysLayerLogMessage(instance, XR_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT, "XrCreateSession",
            OverlaysLayerNoObjectInfo, "WARNING: couldn't connect to main app.\n");
        return XR_ERROR_INITIALIZATION_FAILED;
    }

    // Set pointers absolute so they are valid in our process space again
    header->makePointersAbsolute(ipcbuf.base);

    // Copy anything that were "output" parameters into the command arguments
    IPCCopyOut(&args, argsSerialized);

    // Since Overlays are the parent object of a hierarchy of objects that the Main hosts on behalf of the Overlay,
    // make a unique local XrSession that notes that this is actually an overlay session and any command on this handle has to be proxied.
    // Non-Overlay XrSessions are also replaced locally with a unique local handle in case an overlay app has one.
    XrSession actualHandle = *session;
    XrSession localHandle = GetNextLocalHandle();
 
    std::unique_lock<std::mutex> mlock2(gOverlaysLayerXrSessionToHandleInfoMutex);
    gOverlaysLayerXrSessionToHandleInfo.emplace(std::piecewise_construct, std::forward_as_tuple(localHandle), std::forward_as_tuple(instance, instance, instanceInfo.downchain));
    gOverlaysLayerXrSessionToHandleInfo.at(localHandle).actualHandle = actualHandle;
    gOverlaysLayerXrSessionToHandleInfo.at(localHandle).isOverlaySession = true;
    mlock2.unlock();

    return header->result;
}

(OverlayLayersCreateSessionMain is already implemented)

template <struct T>
const T* FindStructInChain(const T *head, XrStructureType type)
{
    const XrBaseInStructure* p = reinterpret_cast<const XrBaseInStructure*>(head);
    while(p) {
        if(p->type == type) {
            return reinterpret_cast<const T*>(p);
        }
    }
    return nullptr;
}

bool FindExtensionInList(const char* extension, uint32_t extensionsCount, const char * const* extensions)
{
    for(uint32_t i = 0; i < extensionCount; i++) {
        if(strcmp(extension, extensions[i]) == 0) {
            return true;
        }
    }
    return false;
}

XrResult OverlaysLayerCreateSessionMainAsOverlay(
    RPCChannels&                                channels,
    OverlaysLayerRPCCreateSession&              args)
{
    XrResult result;

    *args.session = gMainSession;
    std::unique_lock<std::mutex> mlock(gOverlaysLayerXrSessionToHandleInfoMutex);
    OverlaysLayerXrSessionHandleInfo& sessionInfo = gOverlaysLayerXrSessionToHandleInfo.at(gMainSession);

    if(args.createInfo->createFlags != sessionInfo.createInfo->createFlags) {
        OverlaysLayerLogMessage(gMainInstance, XR_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT, "xrCreateSession",
            OverlaysLayerNoObjectInfo, fmt("WARNING: xrCreateSession for overlay session had different flags (%08X) than those with which main session was created (%08X). Effect is unknown, proceeding anyway.\n", args.createInfo->createFlags, sessionInfo.createInfo->createFlags).c_str());
    }

    // Verify that any structures match that are chained off args.createInfo
    const XrBaseInStructure* p = reinterpret_cast<const XrBaseInStructure*>(args.createInfo->next);
    while(p) {
        switch(p->type) {

            case XR_TYPE_GRAPHICS_BINDING_D3D11_KHR: {
                const XrGraphicsBindingD3D11KHR* d3dbinding = reinterpret_cast<const XrGraphicsBindingD3D11KHR*>(p);
                const XrGraphicsBindingD3D11KHR* other = FindStructInChain(sessionInfo.createInfo->next, p->type);

                if(!other) {
                    // XXX send directly to channels somehow
                    OverlaysLayerLogMessage(gMainInstance, XR_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT, "xrCreateSession",
                        OverlaysLayerNoObjectInfo, "FATAL: xrCreateSession for overlay session specified a XrGraphicsBindingD3D11KHR but main session did not.\n");
                    return XR_INITIALIZATION_FAILURE;
                }

                if(other.device != d3dbinding.device) {
                    OverlaysLayerLogMessage(gMainInstance, XR_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT, "xrCreateSession",
                        OverlaysLayerNoObjectInfo, fmt("WARNING: xrCreateSession for overlay session used different D3D11 Device (%08X) than that with which main session was created (%08X). Effect is unknown, proceeding anyway.\n", d3dbinding.device, other.device).c_str());
                }
                break;
            }

            // XXX Check out all other GAPI structs as support for them is added

            case XR_TYPE_SESSION_CREATE_INFO_OVERLAY_EXTX:
                // This is fine, ignore.  We could probably remove it on the Overlay side and not pass it through...
                break;

            default: {
                char structureTypeName[XR_MAX_STRUCTURE_TYPE_NAME];
                XrResult r = XrStructureTypeToString(gMainInstance, p->type, structureTypeName);
                if(r != XR_SUCCESS) {
                    sprintf(structureTypeName, "(type %08X)", p->type);
                }

                OverlaysLayerLogMessage(gMainInstance, XR_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT, "xrCreateSession",
                    OverlaysLayerNoObjectInfo, fmt("FATAL: xrCreateSession for an overlay session used a struct (%s) which the Overlay API Layer does not know how to check.\n", structureTypeName).c_str());
                return XR_INITIALIZATION_FAILED;
                break;
            }
        }

        p = reinterpret_cast<const XrBaseInStructure*>(p->next);
    }

    // Verify that main session didn't have any unexpected structures that the overlay didn't have
    const XrBaseInStructure* p = reinterpret_cast<const XrBaseInStructure*>(args.createInfo->next);
    while(p) {
        const XrBaseInStructure* other = FindStructInChain(sessionInfo.createInfo->next, p->type);
        if(!other) {
            char structureTypeName[XR_MAX_STRUCTURE_TYPE_NAME];
            XrResult r = XrStructureTypeToString(gMainInstance, p->type, structureTypeName);
            if(r != XR_SUCCESS) {
                sprintf(structureTypeName, "(type %08X)", p->type);
            }

            OverlaysLayerLogMessage(gMainInstance, XR_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT, "xrCreateSession",
                OverlaysLayerNoObjectInfo, fmt("WARNING: xrCreateSession for the main session used a struct (%s) which the overlay session did not. Effect is unknown, proceeding anyway.\n", structureTypeName).c_str());
        }
        p = reinterpret_cast<const XrBaseInStructure*>(p->next);
    }
    
    XrFormFactor mainSessionFormFactor;
    {
        std::unique_lock<std::mutex> m(gOverlaysLayerSessionToHandleInfoMutex);
        OverlaysLayerXrSessionHandleInfo& sessionInfo = gOverlaysLayerXrSessionToHandleInfo.at(gMainSession);
        systemId = sessionInfo.createInfo.systemId;

        // systemId here comes from...?
        std::unique_lock<std::mutex> m2(gOverlaysLayerSystemIdToAtomInfoMutex);
        auto it = gOverlaysLayerSystemIdToAtomInfo.find(systemId);
        XrSystemGetInfo* systemGetInfo = gOverlaysLayerSystemIdToAtomInfo.at(systemId).getInfo;
        mainSessionFormFactor = systemGetInfo->formFactor;
    }
    if(mainSessionFormFactor != args.formFactor) {
        OverlaysLayerLogMessage(gMainInstance, XR_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT, "xrCreateSession",
            OverlaysLayerNoObjectInfo, fmt("FATAL: xrCreateSession for the overlay session used an XrFormFactor (%s) which the main session did not.\n", args.formFactor).c_str());
        return XR_ERROR_INITIALIZATION_FAILED;
    }

    bool didntFindExtension = false;
    {
        std::unique_lock<std::mutex> m(gOverlaysLayerInstanceToHandleInfoMutex);
        OverlaysLayerInstanceToHandleInfo& mainInstanceInfo = gOverlaysLayerInstanceToHandleInfo.at(gMainInstance);
        XrInstanceCreateInfo* mainInstanceCreateInfo = mainInstanceInfo.createInfo;
        for(int i = 0; i < args.instanceCreateInfo->enabledExtensionCount; i++) {
            bool alsoInMain = FindExtensionInList(args.instanceCreateInfo->enabledExtensionNames[i], mainInstanceCreateInfo->enabledExtensionCount, mainInstanceCreateInfo->enabledExtensionNames);
            if(!alsoInMain) {
                OverlaysLayerLogMessage(gMainInstance, XR_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT, "xrCreateSession",
                    OverlaysLayerNoObjectInfo, fmt("FATAL: xrCreateInstance for the parent of the overlay session specified an extension (%s) which the main session did not.\n", args.instanceCreateInfo->enabledExtensionNames[i]).c_str());
                didntFindExtension = true;
            }
        }
    }
    if(didntFindExtension) {
        return XR_ERROR_INITIALIZATION_FAILED;
    }

    create stand in for Main managing all Overlay app's stuff (in case Overlay unexpectedly exits); MainSessionContext

    return result;
}

bool ProcessOverlayRequestOrReturnConnectionLost(RPCChannels& channels, IPCBuffer &ipcbuf, IPCHeader *hdr)
{
    switch(hdr->requestType) {

        // Call into "Overlay_" function to handle functionality
        // altered by Overlay connection and may not be disambiguated by XrSession,
        // or call into "Overlay_" function to handle functionality only altered
        // for the purposes of Overlay composition layers that can be disambiguated
        // by XrSession or child handles

        case IPC_XR_CREATE_SESSION: {
            auto args = ipcbuf.getAndAdvance<OverlaysLayerRPCCreateSession>();
            hdr->result = OverlaysLayerCreateSessionMainAsOverlay(channels, args);
            break;
        }

        // ...

        default: {
            OutputDebugStringA("unknown request type in IPC");
            return true;
            break;
        }
    }
    return false;
}

OverlaysLayerLogMessage
    should key on instance, so that MainAsOverlay calls OverlaysLogMessage with remote instance and it is known to route there
    should key on any proxy objects, so that if runtime encounters any issues, proxy debug messenger can send to overlay...?

DestroySession

destroying main session
    poison all overlay IPC using ConnectionToOverlay
    SetEvent(gNegotiationChannels.mainNegotiateThreadStop);
    WaitForSingleObject(gNegotiationChannels.mainThread, INFINITE);
    gMainSessionInstance = XR_NULL_HANDLE;
    ReleaseMutex(gNegotiationChannels.mainMutexHandle);

destroying instance that was used to create main session
    if(instance == gMainSessionInstance) {
        call same functions as destroy main session
    }



LocalActionSet
    std::vector<LocalAction::Handle> actions;
    std::string name;
    std::string localizedName;
    bool mutable = true; // false after attach
    typedef uint64_t Handle;

LocalAction
    std::string name[XR_MAX_ACTION_NAME_SIZE];
    LocalActionSet::Handle actionSet;
    XrActionType type;
    std::vector<std::string> subactionPaths;
    std::string localizedName
    typedef uint64_t Handle;

Session::
    interaction profile bindings

hello_xr output:
    profile null_path
    bound "grab" to 0 sources...
    bound "pose" to 0 sources...
    bound "quit" to 0 sources...
    bound "vibrate" to 0 sources...
    [15:29:53.457][Info   ] XrEventDataSessionStateChanged: state XR_SESSION_STATE_SYNCHRONIZED->XR_SESSION_STATE_VISIBLE session=72165140019019777 time=1060087400739200
    [15:29:53.458][Info   ] XrEventDataSessionStateChanged: state XR_SESSION_STATE_VISIBLE->XR_SESSION_STATE_FOCUSED session=72165140019019777 time=1060087400774200
    profile oculus/touch_controller
    bound "grab" to 2 sources...
        "/user/hand/left/input/squeeze/value"("Left Hand Oculus Touch Squeeze")
        "/user/hand/right/input/squeeze/value"("Right Hand Oculus Touch Squeeze")
    bound "pose" to 2 sources...
        "/user/hand/left/input/grip/pose"("Left Hand Oculus Touch Grip Pose")
        "/user/hand/right/input/grip/pose"("Right Hand Oculus Touch Grip Pose")
    bound "quit" to 1 sources...
        "/user/hand/left/input/menu/click"("Left Hand Oculus Touch Menu Button")
    bound "vibrate" to 2 sources...
        "/user/hand/left/output/haptic"("Left Hand Oculus Touch Vibration")
        "/user/hand/right/output/haptic"("Right Hand Oculus Touch Vibration")

Actions have arbitrary names and arbitrary localizedNames
    a runtime may not know how to figure out how to map a controller input to an Action

Applications "may" suggest interaction profile bindings
    SuggestInteractionProfileBindings provides a tuple {interaction_profile path, binding path, action}
        EnumerateBoundSourcesForAction provides 0 or more source binding paths for an action
            source binding paths can be changed into strings
            each can be compared against other interaction profile binding path strings
    if bindings aren't suggested, input can't be routed because runtime has no idea what actions mean what
    So, for a given action, IF AN INTERACTION PROFILE BINDING HAS BEEN SUGGESTED, one may reverse-lookup 0 or more interaction profile binding paths for the action.
        e.g. in hello_xr, grabAction for interaction profiles is the following bindings:
            "/interaction_profiles/khr/simple_controller"
                "/user/hand/left/input/select/click"
                "/user/hand/right/input/select/click"
            "/interaction_profiles/oculus/touch_controller"
                "/user/hand/left/input/squeeze/value"
                "/user/hand/right/input/squeeze/value"
            "/interaction_profiles/htc/vive_controller"
                "/user/hand/left/input/squeeze/click"
                "/user/hand/right/input/squeeze/click"
            "/interaction_profiles/microsoft/motion_controller" (bindings same as htc/vive_controller)
                "/user/hand/left/input/squeeze/click"
                "/user/hand/right/input/squeeze/click"
        The list of Paths for a given action can be refined further by using the current interaction profile name
            e.g. if one knows the interaction profile is oculus/touch_controller, then one can know that grabAction is {left,right}/input/squeeze/value
            if one does not know the interaction profile, then what?
                Just check all of them?
        further a subactionpath might disambiguate fully mapping an action to a binding
        if overlay suggests "select/click" for XrAction bar and main suggests "select/click" for XrAction foo, xrGetActionStateBoolean on bar could return the same as for foo.
    However, an app may suggest only khr/simple_controller and not the others.
        what if overlay suggests "khr/simple_controller" "select/click" for XrAction bar, and main suggests "oculus/touch_controller" "squeeze/value" for XrAction foo.
            Should OverlaysLayer be responsible for converting input profiles?
                xrGetCurrentInteractionProfile would need to translate from oculus/touch_controller to khr/simplecontroller
                xrGetActionStateBoolean would need to know {"oculus/touch_controller","squeeze/value"} can be reasonably approximated by {"khr/simple_controller","select/click"}
                Overlay Layer would need a mapping with entries from {main profile, main binding} to {overlay profile, overlay binding}
                if main suggests bindings in a profile that Overlay Layer doesn't know, probably have to punt for now.
                Maybe punt in general if main's selected interaction profile is not suggested at all by overlay.
    overlay XrActions may not have the same types as main XrActions for the same bindings.
        May be able to do conversions one direction but not the other..
        punt here too if they don't match?
    An overlay app may suggest bindings for a profile that don't 100% overlap with 100% of main app's bindings
        also punt, I guess.  Some overlay app Actions won't then receive input.
    Finally, an XrAction may be bound to multiple input paths.  See 11.5.1 - "Resolving a single action bound to multiple inputs or outputs" for how that's resolved
    XrAction -> look up in suggested interaction bindings, refine by current interaction profile, results in >= 0 profile paths
        need to catch profile changed event 

If the Overlay knows what main XrActions are bound to which paths at the moment of xrGetActionState*, it can call xrGetActionState on the main XrAction.
    this won't work until main calls xrSyncActions, or if main calls xrSyncActions... at all?
        Overlay could have main call xrSyncActions if main hasn't called it already, and skip the next main xrSyncActions.
        Is it safe to call twice?
    Overlay will need to read state of all XrActions at xrSyncActions and keep locally, otherwise a call by main to xrSyncActions would make subsequent xrGetActionState calls return inconsistent results.

Main : GetSourcesFromAction(XrPath, 

xrPollEvent
    Main
        if profile changed event, save the current profile
    Overlay
        translate profile changed event if possible
ActionSet:
    xrCreateActionSet
        Main - create normally
        Overlay
            make local container for action
            save off name, localized name, priority
        NO MainAsOverlay
    xrDestroyActionSet
        Main - destroy normally
        Overlay - delete local container

Action:
    xrCreateAction
        Main - create normally
        Overlay - save local state
            make local container for action
            type, name, localized name, subaction paths
            pretend to be runtime: If parent actionSet has been included in a call to xrAttachSessionActionSets, the implementation must return XR_ERROR_ACTIONSETS_ALREADY_ATTACHED.
        NO MainAsOverlay
    xrDestroyAction
        Main - destroy normally
        Overlay - delete local container, delete handle from parent ActionSet

xrSuggestInteractionProfileBindings
    Main
        execute normally
        save bindings for comparison
            only one set of bindings per interaction profile so replace old ones on profile with new ones on profile
    Overlay
        save bindings locally
            only one set of bindings per interaction profile so replace old ones on profile with new ones on profile
        pretend to be runtime
            if any action is in attached action set, XR_ERROR_ACTIONSETS_ALREADY_ATTACHED
            If interaction profile path does not follow structure defined in Interaction Profiles or suggested bindings contain paths that do not follow format defined in Device input subpaths, XR_ERROR_PATH_UNSUPPORTED

xrAttachSessionActionSets
    Overlay
        must pretend to be runtime: return XR_ERROR_ACTIONSETS_ALREADY_ATTACHED if already saved
        per-session copy of sets and actions
    Main
        execute normally
        keep track of attached actionsets -> actions -> paths

xrGetCurrentInteractionProfile
    Main
        execute normally - anything else?
    Overlay
        IPC to main, get profile
            Possible XR_ERROR_ACTIONSET_NOT_ATTACHED if main has not yet Attached
                should overlay app block on AttachActionSets?
        return profile to overlay if it matches any provided to SuggestInteractionProfile on overlay
            otherwise NULL_PATH
    MainAsOverlay
        return some kind of error if Main has not attached yet and returns XR_ERROR_ACTIONSET_NOT_ATTACHED

xrSyncActions
    Main
        execute normally
    Overlay
        IPC Action names and suggestedprofile to MainAsOverlay
    MainAsOverlay
        for all actions on overlay side
            name = suggestedbindings
        xrEnumerateBoundSourcesForAction for all actions on Overlay side
        call xrSyncActions on bound actionsets?
        get all bound actions from Overlay and pass back

xrEnumerateBoundSourcesForAction
    (and xrGetInputSourceLocalizedName, less important)

GetActionState
    xrGetActionStateBoolean
    xrGetActionStateFloat
    xrGetActionStateVector2f
    xrGetActionStatePose
    Overlay
        pretend to be runtime
            if function doesn't match action type, XR_ERROR_ACTION_TYPE_MISMATCH
            XR_ERROR_ACTIONSET_NOT_ATTACHED
        return values previously stored by xrSyncActions
    MainAsOverlay
        nothing?
    Main
        call normally

HapticFeedback
    xrStopHapticFeedback
    xrApplyHapticFeedback
        Overlay
            has to map local actions to remote actions
        MainAsOverlay
            call on Action matching the paths provided
        Main
            normal

xrCreateActionSpace
    For xrCreateActionSpace, the action and a subpath are used to disambiguate which path may be used
        but still an action must be bound to a path through an interaction profile
    need to map overlay action to remote action somehow



need to emit for XrPath, XrAction, XrActionSet, XrSystemId
    Overlay side function to pack up a request to main to create one
        XrPath -> string used on creation in Overlay
        XrActionSet -> XrCreateActionSetInfo used on creation in Overlay
        XrAction -> XrCreateActionInfo used on creation in Overlay
    MainAsOverlay function to create those bits
    need to carefully manage errors

possibly_IPC_commands = { Session and all child handle commands }
in Python, if command_name in IPC_commands,
    emit in CommandName:
        check local handle to see if remote proxy
        if(remote proxy)
            CommandNameOverlay(params)
        else
            CommandNameMain(params)
    emit CommandNameOverlay(params)
        for each handle in parameters in XrSpace, XrSwapchain
            substitute proxy handle
        for each handle in parameters in XrAction, XrActionSet
            if there is no proxy handle, create the proxy handle through main
        for each atom in parameters in XrPath, XrSystemId
            if there is no proxy atom, create the proxy atom through main
        substitute proxy Handles and Paths in parameters to send
        pack up commands, add pointers to list, make pointers relative, send over IPC
        unpack results
        deproxy Handles and Paths in returned parameters
        if created XrSpace or XrSwapchain,
            create unique id, return that
    emit CommandNameMain(params)
        call downchain normally with possible caching of create params
    emit CommandNameMainAsOverlay(params)
        take mutex
        call downchain
        return result
    emit body of thread loop looking in shared mem for command name ID
        make pointers absolute
        call CommandNameMainAsOverlay
        make pointers relative
        return result


void* IPCGetSharedMemory()
{
    return shared_mem;
}

// Call from Overlay when request in shmem is complete
void IPCFinishOverlayRequest()
{
    ReleaseSemaphore(gOverlayRequestSema, 1, nullptr);
}

// Call from Main to get complete request in shmem
IPCWaitResult IPCWaitForOverlayRequestOrTermination()
{
    HANDLE handles[2];

    handles[0] = gOverlayRequestSema;
    handles[1] = gOverlayProcessHandle;

    DWORD result;

    do {
        result = WaitForMultipleObjects(2, handles, FALSE, REMOTE_REQUEST_WAIT_MILLIS);
    } while(result == WAIT_TIMEOUT);

    if(result == WAIT_OBJECT_0 + 0) {
        return IPC_REMOTE_REQUEST_READY;
    }

    if(result == WAIT_OBJECT_0 + 1) {
        return IPC_REMOTE_PROCESS_TERMINATED;
    }

    return IPC_WAIT_ERROR;
}

// Call from Main when response in shmem is complete
void IPCFinishMainResponse()
{
    ReleaseSemaphore(gMainResponseSema, 1, nullptr);
}

// Call from Overlay to get complete request in shmem
IPCWaitResult IPCWaitForMainResponse()
{
    DWORD result;

    HANDLE handles[2];

    handles[0] = gMainResponseSema;
    handles[1] = gMainProcessHandle;

    do {
        result = WaitForMultipleObjects(2, handles, FALSE, MAIN_RESPONSE_WAIT_MILLIS);
    } while(result == WAIT_TIMEOUT);

    if(result == WAIT_OBJECT_0 + 0) {
        return IPC_MAIN_RESPONSE_READY;
    }

    if(result == WAIT_OBJECT_0 + 1) {
        return IPC_MAIN_PROCESS_TERMINATED;
    }

    return IPC_WAIT_ERROR;
}

// Set up shared memory using a named file-mapping object. 
bool MapSharedMemory(UINT32 req_memsize)
{ 
    mutex_handle = CreateMutex(NULL, TRUE, kSharedMutexName);
    if (NULL == mutex_handle) return false;
    bool first = (GetLastError() != ERROR_ALREADY_EXISTS); 

    shared_mem_handle = CreateFileMapping( 
        INVALID_HANDLE_VALUE,   // use sys paging file instead of an existing file
        NULL,                   // default security attributes
        PAGE_READWRITE,         // read/write access
        0,                      // size: high 32-bits
        req_memsize,            // size: low 32-bits
        kSharedMemName);        // name of map object

    if (NULL == shared_mem_handle)
    {
        OutputDebugStringA("**OVERLAY** failed to CreateFileMapping\n");
        if (first) ReleaseMutex(mutex_handle); 
        CloseHandle(mutex_handle);
        return false; 
    }

    // Get a pointer to the file-mapped shared memory, read/write
    shared_mem = MapViewOfFile(shared_mem_handle, FILE_MAP_WRITE, 0, 0, 0);
    if (NULL == shared_mem) 
    {
        OutputDebugStringA("**OVERLAY** failed to MapViewOfFile\n");
        if (first) ReleaseMutex(mutex_handle); 
        CloseHandle(mutex_handle);
        return false; 
    }

    MEMORY_BASIC_INFORMATION mbi = { 0 };
    VirtualQueryEx(GetCurrentProcess(), shared_mem, &mbi, sizeof(mbi));
    mem_size = mbi.RegionSize;

    // First will initialize memory
    if (first)
    {
        memset(shared_mem, '\0', mem_size); 
        ReleaseMutex(mutex_handle);
    }
    
    return true;
}

// Unmap the shared memory and release handle
//
bool UnmapSharedMemory()
{
    // Close handle to mutex
    CloseHandle(mutex_handle);

    // Unmap shared memory from the process's address space
    bool err = UnmapViewOfFile(shared_mem); 
 
    // Close the process's handle to the file-mapping object
    if (!err) err = CloseHandle(shared_mem_handle);

    return err;
} 

